#!/usr/bin/env nu

def prepare-align-list [display] {
  ($in | each {|it| do $display $it | str length} | math max) + 4
}

def align-list [max: int, display, render] {
  $in
  | each {|it|
    let width = do $display $it | str length
    let spaces = generate {|_| {out:" ",next:null}} null | take ($max - $width) | str join ""

    do $render $it | str join $spaces
  }
  | str join "\n"
}


let help_display_list = {|it| $"($it.name)($it.args)"}
let help_render_list = {|it|
    [$"  (ansi lmb)($it.name)(ansi reset)(ansi p)($it.args)" $"(ansi reset)($it.desc)"]
}

def get-all-examples [] {
  ls examples/ 
  | where ($it.name | str ends-with .nix) 
  | get name 
  | sort
  | each {|it| {path: $it, file: (open $it), args: ""}}
  | each {|it| $it | merge {name: ($it.path | str substring 9..-5)}} 
  | each {|it| $it | merge {desc: ($it.file 
    | split row "\n" 
    | get 0 
    | if ($in | str starts-with "#") {
      $"(ansi lmb)($in | str substring 2..)"
    } else {
      ""
    }
  )}}
}

def parse-example [example] {
  let example_file = try {
    open $"examples/($example).nix" 
  } catch {|err| 
    error make {
      msg: $"\nCannot read examples/($example).nix",
      label: {
        text: $err.msg,
        span: (metadata $err).span
      },
      help: $"To see all examples run: (ansi lmb)./build help example(ansi reset)"
    }
    exit 1
  } | split row "\n"

  let separation = $example_file
    | take while {|it| $it | str starts-with "#"} 
    | length

  let description = $example_file
  | range 0..($separation)
  | split list --regex "^#@@@"
  | enumerate
  | each {|block| $block.item
    | enumerate
    | each {|it| 
      $it.item
      | str substring 2..
      | if $it.index == 0 and $block.index == 0 {
        $"(ansi lmb)($in)(ansi reset)"
      } else if $block.index == 1 {
        $"(ansi lgb)($in)(ansi reset)"
      } else {
        $in
      }
    } 
    | str join "\n"
  } 
  | str join "\n\n"

  let code = $example_file
  | range ($separation)..
  | str join "\n"
  | $"(ansi lcb)($in)(ansi reset)"

  { path: $"($env.PWD)/examples/($example).nix", description: $description, code: $code }
}

def "show-help list-examples" [] {
  let examples = get-all-examples

  let max = $examples | prepare-align-list $help_display_list

  print "List of examples:"
  $examples | align-list $max $help_display_list $help_render_list | print
}

def "show-help show-example" [example: string] {
  let example = (parse-example $example)

  print $example.description
  print "\nCode:\n"
  print $example.code
}

def show-help [subhelp: string, args] {
  match [$subhelp, $args] {
    [example []] => (show-help list-examples),
    [example [$example]] => (show-help show-example $example)
    [example $_] => {
      print $"(ansi rb)Too many arguments(ansi reset)\n"
      main help
    }

    $_ => {
      print $"(ansi rb)Unknown help: ($subhelp)(ansi reset)\n"
      main help
    }
  }
}

def "main help" [subhelp?: string, ...args] {
  if $subhelp != null {
    show-help $subhelp $args
    return
  }

  let commands = [
    [name args desc];
    [example "" "Run all examples"]
    [example " <EXAMPLE>" "Run a single example if it is provided"]
    [sync "" "Check parity with nix builtins"]
    [help "" "Show this message"]
    [help " <TOPIC>" "Show expanded help of TOPIC. See `More help`"]
  ]

  let more_help = [
    [name args desc];
    [example "" "List all examples"]
    [example " <EXAMPLE>" "Show details of example"]
  ]

  let commands_spec_width = [$commands $more_help] | flatten | prepare-align-list $help_display_list;

  print $"Usage: (ansi lmb)./build (ansi reset)(ansi p)[COMMAND] [...ARGS](ansi reset)"
  print $"\nCommands:"
  print ($commands | align-list $commands_spec_width $help_display_list $help_render_list)

  print "\nMore help:"
  print ($more_help | align-list $commands_spec_width $help_display_list $help_render_list)
}

def all-examples [--minimal] {
  let examples = {cd examples; ls | where ($it.name | str ends-with .nix) }
  let examples = do $examples

  mut errored = []

  for example in $examples {
    let example = $example.name | str substring 0..-5

    let result = if $minimal {
      (main example $example --minimal -e)
    } else {
      (main example $example -e)
    }

    if $result != null and ($example | str starts-with "error-") == false {
      $errored = $errored | append [[$example $result]]
    }
  }

  print $"(ansi green)\n === FINISHED === \n(ansi reset)"

  print ("Errors: " ++ ($errored | length | into string) ++ "\n")

  for $example in $errored {
    print $" - Example (ansi wb)($example.0)(ansi reset) FAILED"
    print $"(ansi red)($example.1)(ansi reset)"
  }

}

def "main example" [example?: string, --minimal, --get-errors -e] {
  if $example == null {
    # Needs to be compilable for test it
    cargo check

    if $minimal {
      return (all-examples --minimal)
    } else {
      return (all-examples)
    }
  }

  let example = (parse-example $example)

  print $"(ansi wd)($example.path)(ansi reset)"

  if $minimal != true {
    print $example.description
    print "\nCode:\n"
    print $example.code
    print -n "\n"
  }

  let result = do --ignore-errors {
    cargo run --quiet -- ($example.path)
  } | complete

  if $result.exit_code != 0 {
    print -n $result.stdout
    print -en (ansi lrb) $result.stderr (ansi reset)
    print -n "\n"

    if $e {
      return $result.stderr
    } else {
      return $result.exit_code
    }
  } else {
    if $minimal != true {
      print -n $result.stdout
      print -n "\n"
    }
  }
}

def "main sync" [] {
  let remote = nix-instantiate --eval -E builtins | parse --regex '(\w+) = ' | get capture0 | uniq | sort
  let local = cargo run -- -e builtins | parse -r '(\w+) =' | get capture0 | uniq | sort

  let total = $remote | length

  mut implemented = 0

  for attr in $remote {
    if ($local | find $attr | is-empty) {
      print -n $"(ansi rb)❌ "
    } else {
      print -n $"(ansi gb)✅ "
      $implemented += 1
    }

    print -n $attr

    ansi reset | print
  }

  let not_implemented = $total - $implemented

  print $"\nTotal       : ($total)"
  print $"Implemented : ($implemented)"
  print $"To do       : ($not_implemented)"
}

def main [] {
  print -e $"(ansi red)TODO: main entry(ansi reset)"
  main help
}
